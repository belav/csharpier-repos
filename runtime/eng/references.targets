<Project>
    <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
        <!--
      Disable RAR from transitively discovering dependencies for references. This is required as we don't copy
      dependencies over into the output directory which means RAR can't resolve them.
    -->
        <_FindDependencies>false</_FindDependencies>
    </PropertyGroup>
    <!-- Project references shouldn't be copied to the output for reference, source, or generator projects. -->
    <ItemDefinitionGroup Condition="'$(IsSourceProject)' == 'true' or '$(IsReferenceAssemblyProject)' == 'true' or '$(IsGeneratorProject)' == 'true'">
        <ProjectReference>
            <Private>false</Private>
        </ProjectReference>
    </ItemDefinitionGroup>
    <ItemGroup Condition="'@(ProjectReference)' != ''">
        <_coreLibProjectReference Include="@(ProjectReference-&gt;WithMetadataValue('Identity', '$(CoreLibProject)'))" />
        <ProjectReference Update="@(_coreLibProjectReference)" Private="false">
            <SetConfiguration Condition="'$(RuntimeFlavor)' == 'CoreCLR' and&#xD;&#xA;                                   '$(Configuration)' != '$(CoreCLRConfiguration)'">Configuration=$(CoreCLRConfiguration)</SetConfiguration>
            <SetConfiguration Condition="'$(RuntimeFlavor)' == 'Mono' and&#xD;&#xA;                                   '$(Configuration)' != '$(MonoConfiguration)'">Configuration=$(MonoConfiguration)</SetConfiguration>
        </ProjectReference>
        <!-- If a CoreLib ProjectReference is present, make all P2P assets non transitive. -->
        <ProjectReference Update="@(ProjectReference-&gt;WithMetadataValue('PrivateAssets', ''))" PrivateAssets="all" Condition="'$(IsSourceProject)' == 'true' and '@(_coreLibProjectReference)' != ''" />
    </ItemGroup>
    <!-- Make shared framework assemblies not app-local (non private). -->
    <Target Name="UpdateProjectReferencesWithPrivateAttribute" AfterTargets="AssignProjectConfiguration" BeforeTargets="PrepareProjectReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xD;&#xA;                     ('$(IsTestProject)' == 'true' or '$(IsTestSupportProject)' == 'true') and&#xD;&#xA;                     '@(ProjectReferenceWithConfiguration)' != ''">
        <ItemGroup>
            <ProjectReferenceWithConfiguration PrivateAssets="all" Private="false" Condition="$(NetCoreAppLibrary.Contains('%(Filename);'))" />
        </ItemGroup>
    </Target>
    <!-- An opt-in target to trim out private assemblies from the ref assembly ReferencePath. -->
    <Target Name="TrimOutPrivateAssembliesFromReferencePath" Condition="'$(CompileUsingReferenceAssemblies)' == 'true' and '$(TrimOutPrivateAssembliesFromReferencePath)' == 'true'" AfterTargets="FindReferenceAssembliesForReferences">
        <ItemGroup>
            <ReferencePathWithRefAssemblies Remove="@(ReferencePathWithRefAssemblies)" Condition="$(NetCoreAppLibraryNoReference.Contains('%(Filename);'))" />
        </ItemGroup>
    </Target>
    <Target Name="ReplaceCoreLibSrcWithRefAssemblyForCompilation" AfterTargets="FindReferenceAssembliesForReferences" Condition="'$(CompileUsingReferenceAssemblies)' != 'true' and '@(_coreLibProjectReference)' != ''">
        <ItemGroup>
            <_resolvedCoreLibProjectReference Include="@(_ResolvedProjectReferencePaths-&gt;WithMetadataValue('MSBuildSourceProjectFile','$(CoreLibProject)'))" />
            <ReferencePathWithRefAssemblies Remove="@(_resolvedCoreLibProjectReference)" />
            <ReferencePathWithRefAssemblies Include="@(_resolvedCoreLibProjectReference-&gt;Metadata('ReferenceAssembly'))" />
        </ItemGroup>
    </Target>
</Project>
